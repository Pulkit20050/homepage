<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Veriface - Attendance Capture (Fixed Mediapipe + Aspect Ratio)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Mediapipe face_detection -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <style>
    :root{
      --primary-color:#4f46e5; --primary-hover:#4338ca;
      --secondary-color:#64748b; --secondary-hover:#475569;
      --bg-light:#f8fafc; --bg-white:#ffffff; --border-color:#e2e8f0;
      --text-dark:#1e293b; --text-light:#64748b;
      --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }
    *{box-sizing:border-box}
    body{font-family:'Poppins',sans-serif;margin:0;background:var(--bg-light);color:var(--text-dark)}
    .header{background:var(--bg-white);padding:1rem 2rem;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border-color)}
    .brand{font-size:1.5rem;font-weight:700;color:var(--primary-color)}
    .main-content{padding:2rem;display:flex;flex-direction:column;align-items:center;gap:2rem}
    .capture-card{background:var(--bg-white);border-radius:12px;box-shadow:var(--shadow);padding:2.5rem;text-align:center;width:100%;max-width:900px}
    .camera-icon-container{cursor:pointer;margin-bottom:2.5rem;transition:transform .2s}
    .camera-icon-container:hover{transform:scale(1.05)}
    .camera-icon{width:72px;height:72px;color:var(--primary-color)}
    .action-buttons{display:flex;justify-content:center;gap:1rem;flex-wrap:wrap}
    .btn{display:inline-flex;align-items:center;gap:.5rem;padding:.75rem 1.5rem;border-radius:8px;border:none;font-weight:500;cursor:pointer}
    .btn-primary{background:var(--primary-color);color:#fff}
    .btn-secondary{background:var(--secondary-color);color:#fff}
    .btn:disabled{background:#d1d5db;color:#9ca3af;cursor:not-allowed}
    .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal-overlay.show{display:flex}
    .modal-content{position:relative;background:var(--bg-white);padding:1.25rem;border-radius:12px;box-shadow:var(--shadow);width:92%;max-width:980px}
    .modal-close-btn{position:absolute;top:8px;right:8px;background:var(--bg-light);border:none;border-radius:50%;width:32px;height:32px;cursor:pointer;font-size:1.25rem}
    /* Video container no longer uses fixed padding-top; JS will size it to video's aspect ratio */
    .modal-video-container{position:relative;width:100%;max-width:920px;background:#000;border-radius:8px;overflow:hidden}
    #webcam,#output_canvas{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:contain}
    .modal-capture-btn{background:#fff;border:4px solid var(--primary-color);border-radius:50%;width:64px;height:64px;cursor:pointer;display:block;margin:1.25rem auto}
    .photo-gallery{display:flex;flex-wrap:wrap;gap:1rem;justify-content:center;max-width:920px}
    .photo-gallery img{width:160px;height:120px;object-fit:cover;border-radius:8px;border:3px solid var(--border-color);box-shadow:var(--shadow)}
    .status{min-height:28px;padding:.5rem 1rem;border-radius:8px;font-weight:500}
    .status.success{background:#dcfce7;color:#166534}
    .status.error{background:#fee2e2;color:#991b1b}
    .status.info{background:#e0f2fe;color:#075985}
    /* Late modal footer */
    .modal-footer{margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border-color);text-align:right}
    .checkbox-item{display:flex;align-items:center;gap:.5rem;margin:6px 0}
    .report-table{width:100%;border-collapse:collapse}
    .report-table th,.report-table td{padding:.6rem;border-bottom:1px solid var(--border-color);text-align:left}
  </style>
</head>
<body>
  <header class="header">
    <div class="brand">Veriface</div>
  </header>

  <main class="main-content">
    <div class="capture-card">
      <h2>Capture Attendance</h2>
      <p>Click the camera to start a session. You can capture multiple photos of the class.</p>

      <div id="openCameraModalBtn" class="camera-icon-container" title="Open camera">
        <svg class="camera-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z"/>
          <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z"/>
        </svg>
      </div>

      <div class="action-buttons">
        <button id="openLateModalBtn" class="btn btn-secondary">Mark Late Arrivals</button>
        <button id="uploadBtn" class="btn btn-primary" disabled>Upload Attendance</button>
      </div>
    </div>

    <p id="status" class="status"></p>
    <div id="photoGallery" class="photo-gallery" aria-live="polite"></div>
  </main>

  <!-- Camera Modal -->
  <div id="cameraModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content">
      <button id="closeCameraModalBtn" class="modal-close-btn" aria-label="Close">&times;</button>
      <div id="modalVideoContainer" class="modal-video-container">
        <!-- video and canvas will be sized to the actual camera aspect ratio -->
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="output_canvas"></canvas>
      </div>
      <button id="modalCaptureBtn" class="modal-capture-btn" title="Capture photo"></button>
    </div>
  </div>

  <!-- Late Modal -->
  <div id="lateModal" class="modal-overlay">
    <div class="modal-content">
      <button id="closeLateModalBtn" class="modal-close-btn" aria-label="Close">&times;</button>
      <h3>Mark Late Arrivals</h3>
      <div id="lateStudentChecklist" class="checkbox-list" style="max-height:240px;overflow:auto"></div>
      <div class="modal-footer">
        <button id="submitLateBtn" class="btn btn-primary">Submit</button>
      </div>
    </div>
  </div>

  <!-- Report Modal (kept for completeness) -->
  <div id="reportModal" class="modal-overlay">
    <div class="modal-content">
      <button id="closeReportModalBtn" class="modal-close-btn" aria-label="Close">&times;</button>
      <h3>Latest Attendance Report</h3>
      <div id="reportContent"></div>
    </div>
  </div>

  <script>
    /* ========= CONFIG ========= */
    const SERVER_URL = 'http://localhost:5000';

    /* ========= ELEMENTS ========= */
    const openCameraModalBtn = document.getElementById('openCameraModalBtn');
    const cameraModal = document.getElementById('cameraModal');
    const closeCameraModalBtn = document.getElementById('closeCameraModalBtn');
    const modalVideoContainer = document.getElementById('modalVideoContainer');
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const modalCaptureBtn = document.getElementById('modalCaptureBtn');

    const openLateModalBtn = document.getElementById('openLateModalBtn');
    const lateModal = document.getElementById('lateModal');
    const closeLateModalBtn = document.getElementById('closeLateModalBtn');
    const lateStudentChecklist = document.getElementById('lateStudentChecklist');
    const submitLateBtn = document.getElementById('submitLateBtn');

    const uploadBtn = document.getElementById('uploadBtn');
    const photoGallery = document.getElementById('photoGallery');
    const statusEl = document.getElementById('status');

    const reportModal = document.getElementById('reportModal');
    const closeReportModalBtn = document.getElementById('closeReportModalBtn');
    const reportContent = document.getElementById('reportContent');

    /* ========= STATE ========= */
    let videoStream = null;
    let faceDetection = null;
    let processingFrame = false;

    /* ========= STUDENTS ========= */
    const studentList = ["Student A", "Student B", "Student C", "Chris Evans", "Elon Musk", "Emma Watson", "John Doe", "Jane Smith"];
    function populateLateCheckboxes(){
      lateStudentChecklist.innerHTML = '';
      studentList.forEach(name=>{
        const id = 'student-' + encodeURIComponent(name);
        const row = document.createElement('div');
        row.className = 'checkbox-item';
        row.innerHTML = `<input type="checkbox" id="${id}"><label for="${id}">${name}</label>`;
        lateStudentChecklist.appendChild(row);
      });
    }
    document.addEventListener('DOMContentLoaded', populateLateCheckboxes);

    /* ========= UTIL: safe bounding box drawing ========= */
    function drawBoundingBoxFromDetection(det, canvasW, canvasH){
      // det.boundingBox might be pixels or normalized (0..1); detect and scale accordingly
      const bb = det.boundingBox || {};
      let xCenter = bb.xCenter ?? 0;
      let yCenter = bb.yCenter ?? 0;
      let w = bb.width ?? 0;
      let h = bb.height ?? 0;

      // If width looks normalized (<= 1), scale to canvas size
      if (w <= 1.0 && h <= 1.0) {
        xCenter *= canvasW;
        yCenter *= canvasH;
        w *= canvasW;
        h *= canvasH;
      }

      const x = xCenter - w / 2;
      const y = yCenter - h / 2;

      canvasCtx.strokeStyle = '#4f46e5';
      canvasCtx.lineWidth = Math.max(2, Math.round(Math.min(canvasW, canvasH) * 0.008));
      canvasCtx.strokeRect(x, y, w, h);
    }

    /* ========= CAMERA START/STOP + aspect handling ========= */
    async function startCamera(){
      try{
        // request environment facing camera (rear) if available
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });

        videoElement.srcObject = videoStream;

        // wait until we have metadata (actual dimensions)
        await new Promise((resolve) => {
          if (videoElement.readyState >= 2 && videoElement.videoWidth) return resolve();
          const onLoaded = () => { videoElement.removeEventListener('loadedmetadata', onLoaded); resolve(); };
          videoElement.addEventListener('loadedmetadata', onLoaded);
        });

        // set canvas pixel size to video size (important for non-stretched drawing)
        adjustVideoAndCanvasSize();

        // initialize mediapipe if not already
        ensureFaceDetection();

        // start frame loop
        processingFrame = true;
        frameLoop();

      }catch(err){
        console.error('startCamera error:', err);
        statusEl.textContent = '❌ Camera error: ' + (err.message || err);
        statusEl.className = 'status error';
      }
    }

    function stopCamera(){
      processingFrame = false;
      if (videoStream){
        videoStream.getTracks().forEach(t => t.stop());
        videoStream = null;
      }
      videoElement.pause();
      videoElement.srcObject = null;
    }

    function adjustVideoAndCanvasSize(){
      // make canvas match the video intrinsic pixel size
      const vidW = videoElement.videoWidth || 640;
      const vidH = videoElement.videoHeight || 480;
      canvasElement.width = vidW;
      canvasElement.height = vidH;

      // size the visible container to preserve aspect ratio so CSS doesn't stretch
      // compute padding-top % or explicit height to preserve ratio
      const containerWidth = modalVideoContainer.clientWidth || Math.min(920, window.innerWidth - 48);
      const targetHeight = Math.round((vidH / vidW) * containerWidth);
      modalVideoContainer.style.height = targetHeight + 'px';

      // ensure CSS object-fit prevents distortion
      videoElement.style.objectFit = 'contain';
      canvasElement.style.objectFit = 'contain';
    }

    // handle window resize to keep aspect ratio correct
    window.addEventListener('resize', () => { if (videoElement && videoElement.videoWidth) adjustVideoAndCanvasSize(); });

    /* ========= Mediapipe face detection setup ========= */
    function ensureFaceDetection(){
      if (faceDetection) return;

      if (typeof FaceDetection === 'undefined') {
        console.error('Mediapipe FaceDetection is not loaded.');
        statusEl.textContent = '❌ FaceDetection library failed to load.';
        statusEl.className = 'status error';
        return;
      }

      faceDetection = new FaceDetection({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
      });
      faceDetection.setOptions({
        model: 'short', // 'short' is faster; 'full' is more accurate
        minDetectionConfidence: 0.5
      });

      faceDetection.onResults((results) => {
        // draw camera frame into canvas at full resolution
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // results.image is an HTMLVideoElement or HTMLCanvasElement - draw to our canvas at full size
        try {
          canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        } catch (err) {
          // fallback if results.image not available
          if (videoElement && videoElement.videoWidth) {
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
          }
        }

        // draw boxes (scale if detection bounding boxes are normalized)
        if (results.detections && results.detections.length) {
          for (const det of results.detections) {
            drawBoundingBoxFromDetection(det, canvasElement.width, canvasElement.height);
          }
        }
      });
    }

    /* ========= Frame loop: await send to avoid piling up frames ========= */
    async function frameLoop(){
      if (!processingFrame || !videoStream) return;
      // wait until faceDetection is ready
      if (!faceDetection) {
        // try again in next tick
        requestAnimationFrame(frameLoop);
        return;
      }

      // ensure canvas size matches video (the first few frames may change)
      if (videoElement.videoWidth && (canvasElement.width !== videoElement.videoWidth || canvasElement.height !== videoElement.videoHeight)) {
        adjustVideoAndCanvasSize();
      }

      try {
        // await send so we don't queue up lots of frames
        await faceDetection.send({ image: videoElement });
      } catch (err) {
        // sometimes faceDetection throws when internal model is not ready — just log and continue
        console.warn('faceDetection.send error (ignored this frame):', err);
      } finally {
        // next frame
        requestAnimationFrame(frameLoop);
      }
    }

    /* ========= Capture (create thumbnail from current canvas) ========= */
    function capturePhoto(){
      if (!canvasElement.width || !canvasElement.height) {
        statusEl.textContent = '⚠️ Camera not ready to capture.';
        statusEl.className = 'status info';
        return;
      }
      const dataUrl = canvasElement.toDataURL('image/jpeg', 0.75);
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = 'Captured photo';
      photoGallery.appendChild(img);
      uploadBtn.disabled = false;
      statusEl.textContent = 'Captured photo ✔️';
      statusEl.className = 'status success';
    }

    /* ========= Upload logic (FormData) ========= */
    async function uploadPhotos(){
      const imgs = Array.from(document.querySelectorAll('#photoGallery img'));
      if (imgs.length === 0) {
        statusEl.textContent = 'No photos to upload.';
        statusEl.className = 'status info';
        return;
      }
      uploadBtn.disabled = true;
      statusEl.textContent = 'Uploading...';
      statusEl.className = 'status info';

      const form = new FormData();
      imgs.forEach((img, i) => {
        form.append(`image_${i}`, dataURLtoBlob(img.src), `photo_${i}.jpg`);
      });

      try {
        const res = await fetch(`${SERVER_URL}/upload`, { method: 'POST', body: form });
        if (!res.ok) throw new Error('Server returned ' + res.status);
        const json = await res.json();
        statusEl.textContent = `✅ ${json.message || 'Upload successful'}`;
        statusEl.className = 'status success';
        photoGallery.innerHTML = ''; // clear after success
        uploadBtn.disabled = true;
      } catch (err) {
        console.error('Upload error:', err);
        statusEl.textContent = '❌ Upload failed.';
        statusEl.className = 'status error';
      } finally {
        uploadBtn.disabled = false;
      }
    }

    function dataURLtoBlob(dataURL){
      const [meta, base64] = dataURL.split(',');
      const mime = meta.match(/:(.*?);/)[1];
      const bin = atob(base64);
      const arr = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
      return new Blob([arr], { type: mime });
    }

    /* ========= Report fetch (unchanged logic but safe) ========= */
    async function fetchAndDisplayReport(){
      reportContent.innerHTML = '<p>Loading report...</p>';
      reportModal.classList.add('show');
      try {
        const res = await fetch(`${SERVER_URL}/get-latest-report`);
        if (!res.ok) throw new Error('Failed to fetch report');
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          reportContent.innerHTML = '<p>No attendance data found.</p>';
          return;
        }
        const table = document.createElement('table');
        table.className = 'report-table';
        table.innerHTML = `<thead><tr><th>Timestamp</th><th>Name</th><th>Status</th></tr></thead>`;
        const tbody = document.createElement('tbody');
        data.forEach(row=>{
          const statusText = row['Status (Present/Absent)'] || row.Status || 'Unknown';
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${row.Timestamp || ''}</td><td>${row.Name || ''}</td><td>${statusText}</td>`;
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        reportContent.innerHTML = '';
        reportContent.appendChild(table);
      } catch (err) {
        console.error('report fetch error:', err);
        reportContent.innerHTML = `<p style="color:red">Error: ${err.message}</p>`;
      }
    }

    /* ========= Submit late arrivals ========= */
    async function submitLateArrivals(){
      const checked = Array.from(lateStudentChecklist.querySelectorAll('input[type="checkbox"]:checked'));
      if (checked.length === 0) { alert('Please select at least one student.'); return; }
      const lateStudents = checked.map(cb => cb.parentElement.querySelector('label').textContent);
      submitLateBtn.disabled = true;
      submitLateBtn.textContent = 'Submitting...';
      try {
        const res = await fetch(`${SERVER_URL}/mark-late`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ late_students: lateStudents })
        });
        if (!res.ok) throw new Error('Server returned ' + res.status);
        const json = await res.json();
        statusEl.textContent = `✅ ${json.message || 'Late arrivals recorded'}`;
        statusEl.className = 'status success';
        // clear checkboxes
        checked.forEach(cb => cb.checked = false);
        lateModal.classList.remove('show');
      } catch(err){
        console.error('submitLateArrivals error:', err);
        statusEl.textContent = '❌ Failed to submit late arrivals.';
        statusEl.className = 'status error';
      } finally {
        submitLateBtn.disabled = false;
        submitLateBtn.textContent = 'Submit';
      }
    }

    /* ========= UI events ========= */
    openCameraModalBtn.addEventListener('click', () => {
      cameraModal.classList.add('show');
      startCamera();
    });
    closeCameraModalBtn.addEventListener('click', () => {
      cameraModal.classList.remove('show');
      stopCamera();
    });
    modalCaptureBtn.addEventListener('click', capturePhoto);
    uploadBtn.addEventListener('click', uploadPhotos);

    openLateModalBtn.addEventListener('click', () => lateModal.classList.add('show'));
    closeLateModalBtn.addEventListener('click', () => lateModal.classList.remove('show'));
    submitLateBtn.addEventListener('click', submitLateArrivals);

    closeReportModalBtn.addEventListener('click', () => reportModal.classList.remove('show'));

    // safe keyboard / overlay close (optional)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cameraModal.classList.remove('show'); stopCamera();
        lateModal.classList.remove('show');
        reportModal.classList.remove('show');
      }
    });

    /* ========= Helpful debug info (show if Mediapipe didn't initialize) ========= */
    // if FaceDetection wasn't loaded by the time DOMContentLoaded fired, show warning.
    window.addEventListener('load', () => {
      if (typeof FaceDetection === 'undefined') {
        console.warn('Mediapipe FaceDetection library not found. Confirm CDN load.');
        statusEl.textContent = '⚠️ Warning: Mediapipe FaceDetection library not loaded. Detection will not run.';
        statusEl.className = 'status info';
      }
    });

  </script>
</body>
</html>
